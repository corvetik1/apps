# Система разрешений на основе CASL

## Обзор

Данная система разрешений реализована с использованием библиотеки CASL и обеспечивает гибкое управление доступом к различным ресурсам приложения на основе ролей пользователей и дополнительных условий.

## Архитектура системы

### Ключевые компоненты

- **types.ts** - содержит перечисления `Action` и `Subject`, определяющие доступные действия и сущности
- **abilities.ts** - основной модуль, реализующий логику проверки разрешений на основе CASL
- **roles.ts** - декларативное описание разрешений для каждой роли

### Роли в системе

Система поддерживает следующие роли:

| Роль      | Описание                                               |
| --------- | ------------------------------------------------------ |
| `Admin`   | Полный доступ ко всем ресурсам системы                 |
| `Manager` | Расширенные права, но с некоторыми ограничениями       |
| `User`    | Базовый пользователь с доступом к собственным ресурсам |
| `Guest`   | Минимальные права, только чтение публичных отчетов     |

## Принцип работы

Система использует библиотеку CASL для определения и проверки разрешений. Основная логика реализована в функции `defineAbilitiesFor`, которая создает объект способностей (abilities) на основе роли пользователя.

### Разграничение доступа по ролям

#### Администратор (Admin)

Администратор имеет полный доступ ко всем ресурсам системы без каких-либо ограничений:

```typescript
if (user.role === Role.Admin) {
  can(Action.Manage, 'all');
  return build();
}
```

#### Менеджер (Manager)

Менеджер имеет расширенные права, но с некоторыми ограничениями:

```typescript
if (user.role === Role.Manager) {
  can([Action.Read, Action.Create, Action.Update], 'all');
  can(Action.Manage, [Subject.Account, Subject.Transaction, Subject.Tender]);
  can([Action.Read, Action.Update], Subject.Settings);
  can(Action.Manage, Subject.User);
}
```

Менеджер может:

- Управлять пользователями (кроме администраторов)
- Полный доступ к счетам, транзакциям и тендерам
- Чтение и обновление настроек (но не удаление)

#### Пользователь (User)

Обычный пользователь имеет доступ только к своим ресурсам и ресурсам своего отдела:

```typescript
if (user.role === Role.User) {
  // Доступ к своему профилю
  if (user.id) {
    can([Action.Read, Action.Update], Subject.User, { userId: user.id } as any);
  }

  // Доступ к счетам своего отдела
  if (user.departmentId) {
    can(Action.Read, Subject.Account, { departmentId: user.departmentId } as any);
  }

  // Создание транзакций в пределах лимита
  if (user.transactionLimit) {
    can(Action.Create, Subject.Transaction, { amount: { $lte: user.transactionLimit } } as any);
  }

  // Доступ к тендерам, отчетам и дашбордам
  can(Action.Read, Subject.Tender);
  can(Action.Read, [Subject.Report, Subject.Dashboard]);
}
```

Пользователь может:

- Просматривать и редактировать только свой профиль
- Видеть счета только своего отдела
- Создавать транзакции в пределах установленного лимита
- Просматривать тендеры, отчеты и дашборды

#### Гость (Guest)

Гость имеет минимальные права:

```typescript
if (user.role === Role.Guest) {
  can(Action.Read, [Subject.Report, Subject.Dashboard], { isPublic: true } as any);
}
```

Гость может:

- Просматривать только публичные отчеты и дашборды

### Условия доступа

Система поддерживает различные условия доступа:

| Условие        | Описание                           | Пример                                        |
| -------------- | ---------------------------------- | --------------------------------------------- |
| `userId`       | Доступ только к своему профилю     | `{ userId: user.id }`                         |
| `departmentId` | Доступ к ресурсам своего отдела    | `{ departmentId: user.departmentId }`         |
| `amount`       | Проверка лимита транзакций         | `{ amount: { $lte: user.transactionLimit } }` |
| `isPublic`     | Доступ только к публичным ресурсам | `{ isPublic: true }`                          |

## Использование в компонентах

### Проверка разрешений

Для проверки разрешений используйте функцию `hasPermission`:

```typescript
// Проверка, может ли пользователь редактировать профиль
const canEditProfile = hasPermission(user, Action.Update, Subject.User, profileResource);

// Проверка, может ли пользователь создать транзакцию
const canCreateTransaction = hasPermission(
  user,
  Action.Create,
  Subject.Transaction,
  transactionData,
);
```

### Использование в React-компонентах

В React-компонентах рекомендуется использовать хук `useAuth`:

```typescript
import { useAuth } from 'src/auth/hooks/useAuth';

const MyComponent = () => {
  const { user, hasPermission } = useAuth();

  // Проверка разрешения
  const canEditSettings = hasPermission(Action.Update, Subject.Settings);

  // Условный рендеринг
  return (
    <div>
      {canEditSettings && <SettingsForm />}
      {!canEditSettings && <AccessDeniedMessage />}
    </div>
  );
};
```

### Защита маршрутов

Для защиты маршрутов используйте компонент `ProtectedRoute`:

```typescript
<Route
  path="/settings"
  element={
    <ProtectedRoute requiredPermission={{ action: Action.Update, subject: Subject.Settings }}>
      <SettingsPage />
    </ProtectedRoute>
  }
/>
```

## Тестирование разрешений

Для тестирования разрешений созданы специальные тесты в директории `__tests__/abilities.test.ts`. Эти тесты проверяют корректность работы системы разрешений для всех ролей и условий.

### Примеры тестов

```typescript
// Тест для администратора
it('должен создавать способности для администратора', () => {
  const adminUser: TestUser = { id: '1', role: Role.Admin };
  const ability = defineAbilitiesFor(adminUser);

  expect(ability.can(Action.Manage, Subject.All)).toBe(true);
});

// Тест для пользователя и доступа к своему профилю
it('должен создавать способности для обычного пользователя', () => {
  const regularUser: TestUser = { id: '3', role: Role.User };
  const ability = defineAbilitiesFor(regularUser);

  const ownProfile: TestResource = { id: '3', userId: '3' };
  const otherProfile: TestResource = { id: '4', userId: '4' };

  expect(ability.can(Action.Read, Subject.User, ownProfile)).toBe(true);
  expect(ability.can(Action.Read, Subject.User, otherProfile)).toBe(false);
});
```

## Лучшие практики

1. **Всегда проверяйте разрешения** перед выполнением операций, даже если интерфейс уже скрывает недоступные элементы
2. **Используйте ProtectedRoute** для защиты маршрутов на уровне маршрутизации
3. **Не полагайтесь только на клиентскую проверку** - серверная часть также должна проверять разрешения
4. **При добавлении новых ролей или разрешений** обязательно добавляйте соответствующие тесты
5. **При работе с MySQL** используйте `as any` для условий или MongoDB-подобные объекты

## Расширение системы

### Добавление новых действий (Action)

Для добавления нового действия:

1. Добавьте новое значение в перечисление `Action` в файле `types.ts`
2. Обновите существующие разрешения в файле `roles.ts` для поддержки нового действия
3. Добавьте тесты для нового действия

### Добавление новых субъектов (Subject)

Для добавления нового субъекта:

1. Добавьте новое значение в перечисление `Subject` в файле `types.ts`
2. Обновите существующие разрешения в файле `roles.ts` для нового субъекта
3. Добавьте проверки для нового субъекта в функцию `defineAbilitiesFor`
4. Добавьте тесты для нового субъекта

### Добавление новых условий

Для добавления нового условия доступа:

1. Определите новую логику условия в файле `defineAbilitiesFor`
2. При необходимости добавьте новые свойства в интерфейсы пользователя и ресурсов
3. Добавьте тесты для нового условия

## Возможные проблемы и их решения

### Проблемы типизации

При работе с CASL и TypeScript могут возникать проблемы с типизацией, особенно при использовании сложных условий. Решения:

1. Использовать приведение типов `as any` для условий доступа
2. При необходимости использовать функции-предикаты, которые принимают и пользователя, и ресурс

### Производительность

При большом количестве правил и условий может снижаться производительность. Рекомендации:

1. Используйте раннее возвращение для администраторов: `if (user.role === Role.Admin) return true`
2. Кэшируйте результаты проверок разрешений для часто используемых комбинаций

## Заключение

Система разрешений на основе CASL обеспечивает гибкий и типобезопасный способ управления доступом в приложении. Она поддерживает различные роли и условия, что позволяет реализовать сложные правила доступа без усложнения кода.

При правильном использовании данная система обеспечивает надежную защиту ресурсов и четкое разграничение прав доступа между различными типами пользователей.
